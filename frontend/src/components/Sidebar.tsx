/* eslint-disable @typescript-eslint/no-explicit-any */
"use client";
import React, { useState, useRef, useEffect, useMemo } from "react";
import { Input } from "@/components/ui/input";
import { Button } from "@/components/ui/button";
import { ScrollArea } from "@/components/ui/scroll-area";
import { Loader2, Download, Upload, Mic } from "lucide-react";
import ReactMarkdown from "react-markdown";
import remarkGfm from "remark-gfm";
import rehypeRaw from "rehype-raw";
import rehypeSanitize from "rehype-sanitize";

// Import shadcn/ui Select components
import {
    Select,
    SelectContent,
    SelectItem,
    SelectTrigger,
    SelectValue,
} from "@/components/ui/select";


// Base API URL - replace with environment variable in production
const API_BASE_URL = process.env.NEXT_PUBLIC_API_URL || "http://localhost:8000";

interface Message {
    from: "user" | "bot";
    text: string;
    loading?: boolean;
}

// --- Translations Object ---
// Add translations for Indian languages (Kannada, Tamil, Hindi)
// Note: The actual diagnosis content from the AI (disease name, details) *should now*
// be in the selected language, but the original *prediction* like "class_name" is still
// based on the English model label. The prompt asks Gemini to elaborate *on* that English label
// in the target language.
const translations: { [key: string]: any } = {
    en: {
        selectLanguage: "Select Language",
        initialMessage: "ЁЯМ┐ Upload an image of the plant to get a diagnosis.",
        uploadedImage: "ЁЯУ╕ Uploaded image:",
        thinking: "Thinking...",
        analysisFailed: "Analysis failed. Please try again.",
        analysisFailedStatus: (status: number) => `Analysis failed with status: ${status}`,
        analysisFailedError: (err: string) => `тЭМ ${err}`,
        healthyPlant: "тЬЕ The plant appears to be healthy.",
        predictionLabel: "Prediction",
        confidenceLabel: "Confidence",
        analysisLabel: "Analysis",
        pdfDownloaded: "тЬЕ Your plant diagnosis report has been downloaded.",
        pdfFailed: (err: string) => `тЭМ ${err instanceof Error ? err.message : 'Failed to generate PDF. Please try again.'}`,
        newDiagnosisButton: "New Diagnosis",
        generateReportButton: "Generate Report",
        generatingReport: "Generating...",
        uploadButton: "Upload Plant Image",
        uploadingButton: "Analyzing...",
        uploadHint: "Upload a clear image of the plant leaves or affected areas",
        inputPlaceholder: "Ask about the diagnosis...",
        sendButton: "Send",
        streamFailed: (err: string) => `тЭМ ${err instanceof Error ? err.message : 'Failed to get response. Please try again.'}`,
        contentDisclaimer: "Note: While the main analysis is in your chosen language, disease names might appear in English.",
        // Add this new disclaimer or modify the existing one
    },
    hi: { // Hindi
        selectLanguage: "рднрд╛рд╖рд╛ рдЪреБрдиреЗрдВ",
        initialMessage: "ЁЯМ┐ рдкреМрдзреЗ рдХреА рдкрд╣рдЪрд╛рди рдХреЗ рд▓рд┐рдП рдПрдХ рддрд╕реНрд╡реАрд░ рдЕрдкрд▓реЛрдб рдХрд░реЗрдВред",
        uploadedImage: "ЁЯУ╕ рдЕрдкрд▓реЛрдб рдХреА рдЧрдИ рддрд╕реНрд╡реАрд░:",
        thinking: "рд╕реЛрдЪ рд░рд╣рд╛ рд╣реИ...",
        analysisFailed: "рд╡рд┐рд╢реНрд▓реЗрд╖рдг рд╡рд┐рдлрд▓ рд╣реБрдЖред рдХреГрдкрдпрд╛ рдкреБрдирдГ рдкреНрд░рдпрд╛рд╕ рдХрд░реЗрдВред",
        analysisFailedStatus: (status: number) => `рд╕реНрдерд┐рддрд┐ ${status} рдХреЗ рд╕рд╛рде рд╡рд┐рд╢реНрд▓реЗрд╖рдг рд╡рд┐рдлрд▓ рд╣реБрдЖред`,
        analysisFailedError: (err: string) => `тЭМ ${err}`,
        healthyPlant: "тЬЕ рдкреМрдзрд╛ рд╕реНрд╡рд╕реНрде рджрд┐рдЦ рд░рд╣рд╛ рд╣реИред",
        predictionLabel: "рднрд╡рд┐рд╖реНрдпрд╡рд╛рдгреА",
        confidenceLabel: "рдЖрддреНрдорд╡рд┐рд╢реНрд╡рд╛рд╕",
        analysisLabel: "рд╡рд┐рд╢реНрд▓реЗрд╖рдг",
        pdfDownloaded: "тЬЕ рдЖрдкрдХреА рдкреМрдзрд╛ рд░реЛрдЧ рдирд┐рджрд╛рди рд░рд┐рдкреЛрд░реНрдЯ рдбрд╛рдЙрдирд▓реЛрдб рд╣реЛ рдЧрдИ рд╣реИред",
        pdfFailed: (err: string) => `тЭМ ${err instanceof Error ? err.message : 'рдкреНрд░рддрд┐рдХреНрд░рд┐рдпрд╛ рдкреНрд░рд╛рдкреНрдд рдХрд░рдиреЗ рдореЗрдВ рд╡рд┐рдлрд▓ рд░рд╣рд╛ред рдХреГрдкрдпрд╛ рдкреБрдирдГ рдкреНрд░рдпрд╛рд╕ рдХрд░реЗрдВред'}`,
        newDiagnosisButton: "рдирдпрд╛ рдирд┐рджрд╛рди",
        generateReportButton: "рд░рд┐рдкреЛрд░реНрдЯ рдЬрдирд░реЗрдЯ рдХрд░реЗрдВ",
        generatingReport: "рдЬрдирд░реЗрдЯ рд╣реЛ рд░рд╣рд╛ рд╣реИ...",
        uploadButton: "рдкреМрдзреЗ рдХреА рддрд╕реНрд╡реАрд░ рдЕрдкрд▓реЛрдб рдХрд░реЗрдВ",
        uploadingButton: "рд╡рд┐рд╢реНрд▓реЗрд╖рдг рд╣реЛ рд░рд╣рд╛ рд╣реИ...",
        uploadHint: "рдкрддреНрддреА рдпрд╛ рдкреНрд░рднрд╛рд╡рд┐рдд рдХреНрд╖реЗрддреНрд░ рдХреА рд╕реНрдкрд╖реНрдЯ рддрд╕реНрд╡реАрд░ рдЕрдкрд▓реЛрдб рдХрд░реЗрдВ",
        inputPlaceholder: "рдирд┐рджрд╛рди рдХреЗ рдмрд╛рд░реЗ рдореЗрдВ рдкреВрдЫреЗрдВ...",
        sendButton: "рднреЗрдЬреЗрдВ",
        streamFailed: (err: string) => `тЭМ ${err instanceof Error ? err.message : 'рдкреНрд░рддрд┐рдХреНрд░рд┐рдпрд╛ рдкреНрд░рд╛рдкреНрдд рдХрд░рдиреЗ рдореЗрдВ рд╡рд┐рдлрд▓ рд░рд╣рд╛ред рдХреГрдкрдпрд╛ рдкреБрдирдГ рдкреНрд░рдпрд╛рд╕ рдХрд░реЗрдВред'}`,
        contentDisclaimer: "рдзреНрдпрд╛рди рджреЗрдВ: рдореБрдЦреНрдп рд╡рд┐рд╢реНрд▓реЗрд╖рдг рдЖрдкрдХреА рдЪреБрдиреА рд╣реБрдИ рднрд╛рд╖рд╛ рдореЗрдВ рд╣реИ, рд▓реЗрдХрд┐рди рд░реЛрдЧ рдХреЗ рдирд╛рдо рдЕрдВрдЧреНрд░реЗрдЬреА рдореЗрдВ рджрд┐рдЦрд╛рдИ рджреЗ рд╕рдХрддреЗ рд╣реИрдВред",
    },
    kn: { // Kannada (Translated using Google Translate, verify with native speaker if possible)
        selectLanguage: "р▓нр▓╛р▓╖р│Ж р▓Жр▓пр│Нр▓Хр│Жр▓ор▓╛р▓бр▓┐",
        initialMessage: "ЁЯМ┐ р▓╕р▓╕р│Нр▓пр▓ж р▓░р│Лр▓Чр▓ир▓┐р▓░р│Нр▓гр▓пр▓Хр│Нр▓Хр▓╛р▓Чр▓┐ р▓Ър▓┐р▓др│Нр▓░р▓╡р▓ир│Нр▓ир│Б р▓Ер▓кр│Нр▓▓р│Лр▓бр│Н р▓ор▓╛р▓бр▓┐.",
        uploadedImage: "ЁЯУ╕ р▓Ер▓кр│Нр▓▓р│Лр▓бр│Н р▓ор▓╛р▓бр▓┐р▓ж р▓Ър▓┐р▓др│Нр▓░:",
        thinking: "р▓Жр▓▓р│Лр▓Ър▓┐р▓╕р│Бр▓др│Нр▓др▓┐р▓жр│Ж...",
        analysisFailed: "р▓╡р▓┐р▓╢р│Нр▓▓р│Зр▓╖р▓гр│Ж р▓╡р▓┐р▓лр▓▓р▓╡р▓╛р▓Чр▓┐р▓жр│Ж. р▓жр▓пр▓╡р▓┐р▓Яр│Нр▓Яр│Б р▓ор▓др│Нр▓др│Ж р▓кр│Нр▓░р▓пр▓др│Нр▓ир▓┐р▓╕р▓┐.",
        analysisFailedStatus: (status: number) => `р▓╕р│Нр▓ер▓┐р▓др▓┐ ${status} р▓пр│Кр▓Вр▓жр▓┐р▓Чр│Ж р▓╡р▓┐р▓╢р│Нр▓▓р│Зр▓╖р▓гр│Ж р▓╡р▓┐р▓лр▓▓р▓╡р▓╛р▓Чр▓┐р▓жр│Ж.`,
        analysisFailedError: (err: string) => `тЭМ ${err}`,
        healthyPlant: "тЬЕ р▓╕р▓╕р│Нр▓пр▓╡р│Б р▓Жр▓░р│Лр▓Чр│Нр▓пр▓Хр▓░р▓╡р▓╛р▓Чр▓┐ р▓Хр▓╛р▓гр│Бр▓др│Нр▓др▓жр│Ж.",
        predictionLabel: "р▓ор│Бр▓ир│Нр▓╕р│Вр▓Ър▓ир│Ж",
        confidenceLabel: "р▓╡р▓┐р▓╢р│Нр▓╡р▓╛р▓╕р▓╛р▓░р│Нр▓╣р▓др│Ж",
        analysisLabel: "р▓╡р▓┐р▓╢р│Нр▓▓р│Зр▓╖р▓гр│Ж",
        pdfDownloaded: "тЬЕ р▓ир▓┐р▓ор│Нр▓о р▓╕р▓╕р│Нр▓п р▓░р│Лр▓Чр▓ир▓┐р▓░р│Нр▓гр▓п р▓╡р▓░р▓жр▓┐р▓пр▓ир│Нр▓ир│Б р▓бр│Мр▓ир│Нр▓▓р│Лр▓бр│Н р▓ор▓╛р▓бр▓▓р▓╛р▓Чр▓┐р▓жр│Ж.",
        pdfFailed: (err: string) => `тЭМ ${err instanceof Error ? err.message : 'р▓кр│Нр▓░р▓др▓┐р▓Хр│Нр▓░р▓┐р▓пр│Жр▓пр▓ир│Нр▓ир│Б р▓кр▓бр│Жр▓пр▓▓р│Б р▓╡р▓┐р▓лр▓▓р▓╡р▓╛р▓Чр▓┐р▓жр│Ж. р▓жр▓пр▓╡р▓┐р▓Яр│Нр▓Яр│Б р▓ор▓др│Нр▓др│Ж р▓кр│Нр▓░р▓пр▓др│Нр▓ир▓┐р▓╕р▓┐.'}`,
        newDiagnosisButton: "р▓╣р│Кр▓╕ р▓░р│Лр▓Чр▓ир▓┐р▓░р│Нр▓гр▓п",
        generateReportButton: "р▓╡р▓░р▓жр▓┐р▓пр▓ир│Нр▓ир│Б р▓░р▓Ър▓┐р▓╕р▓┐",
        generatingReport: "р▓░р▓Ър▓┐р▓╕р▓▓р▓╛р▓Чр│Бр▓др│Нр▓др▓┐р▓жр│Ж...",
        uploadButton: "р▓╕р▓╕р│Нр▓пр▓ж р▓Ър▓┐р▓др│Нр▓░р▓╡р▓ир│Нр▓ир│Б р▓Ер▓кр│Нр▓▓р│Лр▓бр│Н р▓ор▓╛р▓бр▓┐",
        uploadingButton: "р▓╡р▓┐р▓╢р│Нр▓▓р│Зр▓╖р▓┐р▓╕р▓▓р▓╛р▓Чр│Бр▓др│Нр▓др▓┐р▓жр│Ж...",
        uploadHint: "р▓╕р▓╕р│Нр▓пр▓ж р▓Ор▓▓р│Жр▓Чр▓│р│Б р▓Ер▓ер▓╡р▓╛ р▓мр▓╛р▓зр▓┐р▓д р▓кр│Нр▓░р▓жр│Зр▓╢р▓Чр▓│ р▓╕р│Нр▓кр▓╖р│Нр▓Я р▓Ър▓┐р▓др│Нр▓░р▓╡р▓ир│Нр▓ир│Б р▓Ер▓кр│Нр▓▓р│Лр▓бр│Н р▓ор▓╛р▓бр▓┐",
        inputPlaceholder: "р▓░р│Лр▓Чр▓ир▓┐р▓░р│Нр▓гр▓пр▓ж р▓мр▓Чр│Нр▓Чр│Ж р▓Хр│Зр▓│р▓┐...",
        sendButton: "р▓Хр▓│р│Бр▓╣р▓┐р▓╕р▓┐",
        streamFailed: (err: string) => `тЭМ ${err instanceof Error ? err.message : 'р▓кр│Нр▓░р▓др▓┐р▓Хр│Нр▓░р▓┐р▓пр│Жр▓пр▓ир│Нр▓ир│Б р▓кр▓бр│Жр▓пр▓▓р│Б р▓╡р▓┐р▓лр▓▓р▓╡р▓╛р▓Чр▓┐р▓жр│Ж. р▓жр▓пр▓╡р▓┐р▓Яр│Нр▓Яр│Б р▓ор▓др│Нр▓др│Ж р▓кр│Нр▓░р▓пр▓др│Нр▓ир▓┐р▓╕р▓┐.'}`,
        contentDisclaimer: "р▓╕р│Вр▓Ър▓ир│Ж: р▓ор│Бр▓Цр│Нр▓п р▓╡р▓┐р▓╢р│Нр▓▓р│Зр▓╖р▓гр│Ж р▓ир▓┐р▓ор│Нр▓о р▓Жр▓пр│Нр▓ж р▓нр▓╛р▓╖р│Жр▓пр▓▓р│Нр▓▓р▓┐р▓жр│Нр▓жр▓░р│В, р▓░р│Лр▓Чр▓ж р▓╣р│Жр▓╕р▓░р│Бр▓Чр▓│р│Б р▓Зр▓Вр▓Чр│Нр▓▓р▓┐р▓╖р│НтАМр▓ир▓▓р│Нр▓▓р▓┐ р▓Хр▓╛р▓гр▓┐р▓╕р▓┐р▓Хр│Кр▓│р│Нр▓│р▓мр▓╣р│Бр▓жр│Б.",
    },
    ta: { // Tamil (Translated using Google Translate, verify with native speaker if possible)
        selectLanguage: "роорпКро┤ро┐ропрпИродрпН родрпЗро░рпНроирпНродрпЖроЯрпБроХрпНроХро╡рпБроорпН",
        initialMessage: "ЁЯМ┐ родро╛ро╡ро░родрпНродро┐ройрпН роирпЛропро▒ро┐родро▓рпБроХрпНроХро╛роХ роТро░рпБ рокроЯродрпНродрпИрокрпН рокродро┐ро╡рпЗро▒рпНро▒ро╡рпБроорпН.",
        uploadedImage: "ЁЯУ╕ рокродро┐ро╡рпЗро▒рпНро▒рокрпНрокроЯрпНроЯ рокроЯроорпН:",
        thinking: "ропрпЛроЪро┐роХрпНроХро┐ро▒родрпБ...",
        analysisFailed: "рокроХрпБрокрпНрокро╛ропрпНро╡рпБ родрпЛро▓рпНро╡ро┐ропроЯрпИроирпНродродрпБ. родропро╡рпБроЪрпЖропрпНродрпБ роорпАрогрпНроЯрпБроорпН роорпБропро▒рпНроЪро┐роХрпНроХро╡рпБроорпН.",
        analysisFailedStatus: (status: number) => `роиро┐ро▓рпИ ${status} роЙроЯройрпН рокроХрпБрокрпНрокро╛ропрпНро╡рпБ родрпЛро▓рпНро╡ро┐ропроЯрпИроирпНродродрпБ.`,
        analysisFailedError: (err: string) => `тЭМ ${err}`,
        healthyPlant: "тЬЕ родро╛ро╡ро░роорпН роЖро░рпЛроХрпНроХро┐ропрооро╛роХродрпН родрпЖро░ро┐роХро┐ро▒родрпБ.",
        predictionLabel: "роорпБройрпНройро▒ро┐ро╡ро┐рокрпНрокрпБ",
        confidenceLabel: "роироорпНрокро┐роХрпНроХрпИ",
        analysisLabel: "рокроХрпБрокрпНрокро╛ропрпНро╡рпБ",
        pdfDownloaded: "тЬЕ роЙроЩрпНроХро│рпН родро╛ро╡ро░ роирпЛропро▒ро┐родро▓рпН роЕро▒ро┐роХрпНроХрпИ рокродро┐ро╡ро┐ро▒роХрпНроХроорпН роЪрпЖропрпНропрокрпНрокроЯрпНроЯрпБро│рпНро│родрпБ.",
        pdfFailed: (err: string) => `тЭМ ${err instanceof Error ? err.message : 'рокродро┐ро▓рпИрокрпН рокрпЖро▒родрпН родро╡ро▒ро┐ро╡ро┐роЯрпНроЯродрпБ. родропро╡рпБроЪрпЖропрпНродрпБ роорпАрогрпНроЯрпБроорпН роорпБропро▒рпНроЪро┐роХрпНроХро╡рпБроорпН.'}`,
        newDiagnosisButton: "рокрпБродро┐роп роирпЛропро▒ро┐родро▓рпН",
        generateReportButton: "роЕро▒ро┐роХрпНроХрпИропрпИ роЙро░рпБро╡ро╛роХрпНроХро╡рпБроорпН",
        generatingReport: "роЙро░рпБро╡ро╛роХрпНроХрокрпНрокроЯрпБроХро┐ро▒родрпБ...",
        uploadButton: "родро╛ро╡ро░рокрпН рокроЯродрпНродрпИрокрпН рокродро┐ро╡рпЗро▒рпНро▒ро╡рпБроорпН",
        uploadingButton: "рокроХрпБрокрпНрокро╛ропрпНро╡рпБ роЪрпЖропрпНроХро┐ро▒родрпБ...",
        uploadHint: "родро╛ро╡ро░ роЗро▓рпИроХро│рпН роЕро▓рпНро▓родрпБ рокро╛родро┐роХрпНроХрокрпНрокроЯрпНроЯ рокроХрпБродро┐роХро│ро┐ройрпН родрпЖро│ро┐ро╡ро╛рой рокроЯродрпНродрпИрокрпН рокродро┐ро╡рпЗро▒рпНро▒ро╡рпБроорпН",
        inputPlaceholder: "роирпЛропро▒ро┐родро▓рпИрокрпН рокро▒рпНро▒ро┐ роХрпЗро│рпБроЩрпНроХро│рпН...",
        sendButton: "роЕройрпБрокрпНрокрпБ",
        streamFailed: (err: string) => `тЭМ ${err instanceof Error ? err.message : 'рокродро┐ро▓рпИрокрпН рокрпЖро▒родрпН родро╡ро▒ро┐ро╡ро┐роЯрпНроЯродрпБ. родропро╡рпБроЪрпЖропрпНродрпБ роорпАрогрпНроЯрпБроорпН роорпБропро▒рпНроЪро┐роХрпНроХро╡рпБроорпН.'}`,
        contentDisclaimer: "роХрпБро▒ро┐рокрпНрокрпБ: роорпБроХрпНроХро┐роп рокроХрпБрокрпНрокро╛ропрпНро╡рпБ роирпАроЩрпНроХро│рпН родрпЗро░рпНроирпНродрпЖроЯрпБродрпНрод роорпКро┤ро┐ропро┐ро▓рпН роЗро░рпБроирпНродро╛ро▓рпБроорпН, роирпЛропрпНроХро│ро┐ройрпН рокрпЖропро░рпНроХро│рпН роЖроЩрпНроХро┐ро▓родрпНродро┐ро▓рпН родрпЛройрпНро▒роХрпНроХрпВроЯрпБроорпН.",
    },
    // Add more languages as needed
    ml: { // Malayalam (Using Google Translate)
        selectLanguage: "р┤нр┤╛р┤╖ р┤др┤┐р┤░р┤Юр╡Нр┤Юр╡Жр┤Яр╡Бр┤Хр╡Нр┤Хр╡Бр┤Х",
        initialMessage: "ЁЯМ┐ р┤░р╡Лр┤Чр┤ир┤┐р╡╝р┤гр╡Нр┤гр┤пр┤др╡Нр┤др┤┐р┤ир┤╛р┤пр┤┐ р┤Ър╡Жр┤Яр┤┐р┤пр╡Бр┤Яр╡Ж р┤Ър┤┐р┤др╡Нр┤░р┤В р┤Ер┤кр╡НтАМр┤▓р╡Лр┤бр╡Н р┤Ър╡Жр┤пр╡Нр┤пр╡Бр┤Х.",
        uploadedImage: "ЁЯУ╕ р┤Ер┤кр╡НтАМр┤▓р╡Лр┤бр╡Н р┤Ър╡Жр┤пр╡Нр┤д р┤Ър┤┐р┤др╡Нр┤░р┤В:",
        thinking: "р┤Ър┤┐р┤ир╡Нр┤др┤┐р┤Хр╡Нр┤Хр╡Бр┤ир╡Нр┤ир╡Б...",
        analysisFailed: "р┤╡р┤┐р┤╢р┤Хр┤▓р┤ир┤В р┤кр┤░р┤╛р┤Ьр┤пр┤кр╡Нр┤кр╡Жр┤Яр╡Нр┤Яр╡Б. р┤жр┤пр┤╡р┤╛р┤пр┤┐ р┤╡р╡Ар┤гр╡Нр┤Яр╡Бр┤В р┤╢р╡Нр┤░р┤ор┤┐р┤Хр╡Нр┤Хр╡Бр┤Х.",
        analysisFailedStatus: (status: number) => `р┤╕р╡Нр┤▒р╡Нр┤▒р┤╛р┤▒р╡Нр┤▒р┤╕р╡Н ${status} р┤Йр┤кр┤пр╡Лр┤Чр┤┐р┤Ър╡Нр┤Ър╡Н р┤╡р┤┐р┤╢р┤Хр┤▓р┤ир┤В р┤кр┤░р┤╛р┤Ьр┤пр┤кр╡Нр┤кр╡Жр┤Яр╡Нр┤Яр╡Б.`,
        analysisFailedError: (err: string) => `тЭМ ${err}`,
        healthyPlant: "тЬЕ р┤Ър╡Жр┤Яр┤┐ р┤Жр┤░р╡Лр┤Чр╡Нр┤пр┤Хр┤░р┤ор┤╛р┤пр┤┐ р┤Хр┤╛р┤гр┤кр╡Нр┤кр╡Жр┤Яр╡Бр┤ир╡Нр┤ир╡Б.",
        predictionLabel: "р┤кр╡Нр┤░р┤╡р┤Ър┤ир┤В",
        confidenceLabel: "р┤╡р┤┐р┤╢р╡Нр┤╡р┤╛р┤╕р╡Нр┤пр┤д",
        analysisLabel: "р┤╡р┤┐р┤╢р┤Хр┤▓р┤ир┤В",
        pdfDownloaded: "тЬЕ р┤ир┤┐р┤Щр╡Нр┤Щр┤│р╡Бр┤Яр╡Ж р┤Ър╡Жр┤Яр┤┐ р┤░р╡Лр┤Чр┤ир┤┐р╡╝р┤гр╡Нр┤гр┤п р┤▒р┤┐р┤кр╡Нр┤кр╡Лр╡╝р┤Яр╡Нр┤Яр╡Н р┤бр╡Чр╡║р┤▓р╡Лр┤бр╡Н р┤Ър╡Жр┤пр╡Нр┤др╡Б.",
        pdfFailed: (err: string) => `тЭМ ${err instanceof Error ? err.message : 'р┤кр╡Нр┤░р┤др┤┐р┤Хр┤░р┤гр┤В р┤▓р┤нр┤┐р┤Хр╡Нр┤Хр┤╛р╡╗ р┤кр┤░р┤╛р┤Ьр┤пр┤кр╡Нр┤кр╡Жр┤Яр╡Нр┤Яр╡Б. р┤жр┤пр┤╡р┤╛р┤пр┤┐ р┤╡р╡Ар┤гр╡Нр┤Яр╡Бр┤В р┤╢р╡Нр┤░р┤ор┤┐р┤Хр╡Нр┤Хр╡Бр┤Х.'}`,
        newDiagnosisButton: "р┤кр╡Бр┤др┤┐р┤п р┤░р╡Лр┤Чр┤ир┤┐р╡╝р┤гр╡Нр┤гр┤пр┤В",
        generateReportButton: "р┤▒р┤┐р┤кр╡Нр┤кр╡Лр╡╝р┤Яр╡Нр┤Яр╡Н р┤Йр┤гр╡Нр┤Яр┤╛р┤Хр╡Нр┤Хр╡Бр┤Х",
        generatingReport: "р┤Йр┤гр╡Нр┤Яр┤╛р┤Хр╡Нр┤Хр╡Бр┤ир╡Нр┤ир╡Б...",
        uploadButton: "р┤Ър╡Жр┤Яр┤┐р┤пр╡Бр┤Яр╡Ж р┤Ър┤┐р┤др╡Нр┤░р┤В р┤Ер┤кр╡НтАМр┤▓р╡Лр┤бр╡Н р┤Ър╡Жр┤пр╡Нр┤пр╡Бр┤Х",
        uploadingButton: "р┤╡р┤┐р┤╢р┤Хр┤▓р┤ир┤В р┤Ър╡Жр┤пр╡Нр┤пр╡Бр┤ир╡Нр┤ир╡Б...",
        uploadHint: "р┤Ър╡Жр┤Яр┤┐р┤пр╡Бр┤Яр╡Ж р┤Зр┤▓р┤Хр┤│р╡Бр┤Яр╡Жр┤пр╡Л р┤мр┤╛р┤зр┤┐р┤Ър╡Нр┤Ъ р┤нр┤╛р┤Чр┤Щр╡Нр┤Щр┤│р╡Бр┤Яр╡Жр┤пр╡Л р┤╡р╡Нр┤пр┤Хр╡Нр┤др┤ор┤╛р┤п р┤Ър┤┐р┤др╡Нр┤░р┤В р┤Ер┤кр╡НтАМр┤▓р╡Лр┤бр╡Н р┤Ър╡Жр┤пр╡Нр┤пр╡Бр┤Х",
        inputPlaceholder: "р┤░р╡Лр┤Чр┤ир┤┐р╡╝р┤гр╡Нр┤гр┤пр┤др╡Нр┤др╡Жр┤Хр╡Нр┤Хр╡Бр┤▒р┤┐р┤Ър╡Нр┤Ър╡Н р┤Ър╡Лр┤жр┤┐р┤Хр╡Нр┤Хр╡Бр┤Х...",
        sendButton: "р┤Ер┤пр┤Хр╡Нр┤Хр╡Бр┤Х",
        streamFailed: (err: string) => `тЭМ ${err instanceof Error ? err.message : 'р┤кр╡Нр┤░р┤др┤┐р┤Хр┤░р┤гр┤В р┤▓р┤нр┤┐р┤Хр╡Нр┤Хр┤╛р╡╗ р┤кр┤░р┤╛р┤Ьр┤пр┤кр╡Нр┤кр╡Жр┤Яр╡Нр┤Яр╡Б. р┤жр┤пр┤╡р┤╛р┤пр┤┐ р┤╡р╡Ар┤гр╡Нр┤Яр╡Бр┤В р┤╢р╡Нр┤░р┤ор┤┐р┤Хр╡Нр┤Хр╡Бр┤Х.'}`,
        contentDisclaimer: "р┤╢р╡Нр┤░р┤жр╡Нр┤зр┤┐р┤Хр╡Нр┤Хр╡Бр┤Х: р┤кр╡Нр┤░р┤зр┤╛р┤и р┤╡р┤┐р┤╢р┤Хр┤▓р┤ир┤В р┤ир┤┐р┤Щр╡Нр┤Щр╡╛ р┤др┤┐р┤░р┤Юр╡Нр┤Юр╡Жр┤Яр╡Бр┤др╡Нр┤д р┤нр┤╛р┤╖р┤пр┤┐р┤▓р┤╛р┤гр╡Жр┤Щр╡Нр┤Хр┤┐р┤▓р╡Бр┤В, р┤░р╡Лр┤Чр┤Щр╡Нр┤Щр┤│р╡Бр┤Яр╡Ж р┤кр╡Зр┤░р╡Бр┤Хр╡╛ р┤Зр┤Вр┤Чр╡Нр┤▓р╡Ар┤╖р┤┐р╡╜ р┤Хр┤╛р┤гр┤╛р┤В.",
    },
    // ... add other languages
};

// Map language codes to display names
const languageOptions = {
    en: "English",
    hi: "рд╣рд┐рдВрджреА (Hindi)",
    kn: "р▓Хр▓ир│Нр▓ир▓б (Kannada)",
    ta: "родрооро┐ро┤рпН (Tamil)",
    ml: "р┤ор┤▓р┤пр┤╛р┤│р┤В (Malayalam)",
    // Add display names for other languages here
};


const SideChatBot: React.FC = () => {
    // Initialize with English or get from localStorage/context if you want persistence
    const [currentLang, setCurrentLang] = useState('en');
    const t = useMemo(() => translations[currentLang] || translations.en, [currentLang]);

    // Update initial message based on current language state
    const [messages, setMessages] = useState<Message[]>(() => [
        { from: "bot", text: translations[currentLang]?.initialMessage || translations.en.initialMessage }
    ]);
    const [input, setInput] = useState("");
    const [isStreaming, setIsStreaming] = useState(false);
    const [isUploading, setIsUploading] = useState(false);
    const [chatEnabled, setChatEnabled] = useState(false);
    const [diagnosisContext, setDiagnosisContext] = useState(""); // Still store context in English for backend query base
    const [isGeneratingPDF, setIsGeneratingPDF] = useState(false);
    const scrollAreaRef = useRef<HTMLDivElement>(null);
    const fileInputRef = useRef<HTMLInputElement>(null);

    // Auto-scroll to bottom of chat
    useEffect(() => {
        const scrollContainer = scrollAreaRef.current?.querySelector('[data-radix-scroll-area-viewport]');
        if (scrollContainer) {
            scrollContainer.scrollTo({ top: scrollContainer.scrollHeight, behavior: 'smooth' });
        }
    }, [messages]);

    // Effect to update the initial message and potentially the last bot message when language changes
    useEffect(() => {
        // Update initial message if chat hasn't started
        if (!chatEnabled && messages.length === 1 && messages[0].from === 'bot') {
            setMessages([{ from: "bot", text: t.initialMessage }]);
        } else if (messages.length > 0 && messages[messages.length - 1].from === 'bot') {
            // Attempt to update the text of the last bot message if it's one of the known static ones
            const lastMessage = messages[messages.length - 1];
            let updatedText = lastMessage.text;

            // Check if it's the PDF downloaded message and update its translation
            const pdfDownloadedEnglish = translations.en.pdfDownloaded;
            const isPdfDownloaded = Object.values(translations).some(langTrans =>
                lastMessage.text.includes(langTrans.pdfDownloaded)
            );
            if (isPdfDownloaded) {
                updatedText = t.pdfDownloaded;
            }
            // You could add similar checks for other static bot messages if needed,
            // but most bot messages will be dynamic AI output now.

            if (updatedText !== lastMessage.text) {
                setMessages(prev => {
                    const updated = [...prev];
                    updated[updated.length - 1] = { ...lastMessage, text: updatedText };
                    return updated;
                });
            }
        }
    }, [currentLang, chatEnabled]); // Depend on currentLang and chatEnabled


    // Handle language change
    const handleLanguageChange = (lang: string) => {
        setCurrentLang(lang);
        // Reset messages to the initial state in the new language if no diagnosis is in progress
        if (!chatEnabled) {
            setMessages([{ from: "bot", text: translations[lang]?.initialMessage || translations.en.initialMessage }]);
        }
    };


    // Handle image analysis
    const handleImageUpload = async (e: React.ChangeEvent<HTMLInputElement>) => {
        const file = e.target.files?.[0];
        if (!file) return;

        setIsUploading(true);
        setMessages(prev => [...prev,
        { from: "user", text: `${t.uploadedImage} ${file.name}` },
        { from: "bot", text: "", loading: true }
        ]);

        const formData = new FormData();
        formData.append("file", file);
        formData.append("language", currentLang); // *** Send the language code ***

        try {
            const res = await fetch(`${API_BASE_URL}/analyze/`, {
                method: "POST",
                body: formData
            });

            if (!res.ok) {
                let errorDetail = `status: ${res.status}`;
                try {
                    const errorJson = await res.json();
                    if (errorJson.error) {
                        errorDetail = errorJson.error;
                    }
                } catch (e) {
                    // Ignore JSON parsing errors, use status
                }
                throw new Error(errorDetail);
            }

            const data = await res.json();

            // The prediction part still uses the original English class name from the model
            // The gemini_response should be in the target language
            const predictionText = data.prediction.class_index !== null
                ? `**${t.predictionLabel}**: ${data.prediction.class_name} (${t.predictionLabel})\n**${t.confidenceLabel}**: ${(data.prediction.confidence * 100).toFixed(2)}%`
                : t.healthyPlant; // Use translated text for healthy plant

            // data.gemini_response should now be in the target language
            const responseText = `${predictionText}\n\n**${t.analysisLabel}**:\n${data.gemini_response}\n\n---\n*${t.contentDisclaimer}*`; // Add disclaimer

            // Store the original English diagnosis context for follow-up questions if needed
            // Or, store the generated text in the target language?
            // Let's store the English context for the backend prompt structure for now.
            // A more advanced approach might involve translating the user's question
            // on the backend and using that with the original English context.
            // For this implementation, we assume the backend takes the English context
            // and the user's question (potentially in local language) and generates
            // the *response* in the selected language.
            setDiagnosisContext(data.gemini_response); // Storing the generated text as context

            setChatEnabled(true);

            setMessages(prev => {
                const updated = [...prev];
                updated[updated.length - 1] = { from: "bot", text: responseText };
                return updated;
            });
        } catch (err) {
            console.error(err);
            setMessages(prev => {
                const updated = [...prev];
                updated[updated.length - 1] = {
                    from: "bot",
                    text: t.analysisFailedError(err instanceof Error ? err.message : t.analysisFailed)
                };
                return updated;
            });
        } finally {
            setIsUploading(false);
            if (fileInputRef.current) {
                fileInputRef.current.value = "";
            }
        }
    };

    // Handle follow-up Q&A
    const handleSend = async (e?: React.FormEvent) => {
        if (e) {
            e.preventDefault();
        }

        if (!input.trim() || isStreaming) return;

        const question = input; // User input can be in any language
        const currentContext = diagnosisContext; // Get the last generated bot response as context
        setInput("");
        setMessages(prev => [...prev,
        { from: "user", text: question },
        { from: "bot", text: "", loading: true }
        ]);
        setIsStreaming(true);

        try {
            // Send the user's question and the last bot response (as context) to the backend
            // along with the preferred response language.
            const res = await fetch(`${API_BASE_URL}/generate-stream`, {
                method: "POST",
                headers: { "Content-Type": "application/json" },
                // Send the last generated bot response (as context), the user's question, and the language
                body: JSON.stringify({
                    // This combined input will be sent to the backend endpoint
                    // The backend will then add the language instruction to this input before sending to Gemini
                    // We're passing the *last bot response* as context here. If the backend
                    // relied strictly on the *original diagnosis context* (which was English),
                    // you'd pass that instead. Using the last response *might* help Gemini
                    // stay in the current conversation's language context better.
                    input: `Previous diagnosis/response context: "${currentContext}". User asks: "${question}"`,
                    language: currentLang // *** Send the language code ***
                })
            });

            if (!res.ok) {
                // If the initial request fails before streaming starts
                let errorDetail = `status: ${res.status}`;
                try {
                    const errorJson = await res.json();
                    if (errorJson.error) {
                        errorDetail = errorJson.error;
                    }
                } catch (e) {
                    // Ignore JSON parsing errors
                }
                throw new Error(errorDetail);
            }

            const reader = res.body?.getReader();
            const decoder = new TextDecoder("utf-8");
            if (!reader) throw new Error("Failed to create reader");

            setMessages(prev => {
                const updated = [...prev];
                updated[updated.length - 1] = { from: "bot", text: "" }; // Prepare for streaming text
                return updated;
            });

            let receivedText = "";
            while (true) {
                const { done, value } = await reader.read();
                if (done) break;
                const chunk = decoder.decode(value);
                receivedText += chunk; // Accumulate text to potentially update context later
                setMessages(prev => {
                    const updated = [...prev];
                    // Append the chunk to the last message's text
                    updated[updated.length - 1] = {
                        from: "bot",
                        text: updated[updated.length - 1].text + chunk
                    };
                    return updated;
                });
            }
            // Update diagnosisContext with the full received response for future follow-ups
            setDiagnosisContext(receivedText);

        } catch (err) {
            console.error(err);
            setMessages(prev => {
                const updated = [...prev];
                // If loading was still true, replace it with the error message
                if (updated.length > 0 && updated[updated.length - 1].loading) {
                    updated[updated.length - 1] = {
                        from: "bot",
                        text: t.streamFailed(err) // Use translated stream failed message
                    };
                } else {
                    // Or add a new error message if stream failed after some content
                    updated.push({ from: "bot", text: t.streamFailed(err) });
                }
                return updated;
            });
        } finally {
            setIsStreaming(false);
        }
    };

    // Download PDF report (No changes needed here, it sends the current messages which *should*
    // Download PDF report - Corrected to send the expected JSON structure
    const handleDownloadPdf = async () => {
        try {
            setIsGeneratingPDF(true);

            const res = await fetch(`${API_BASE_URL}/generate-pdf/`, {
                method: "POST",
                headers: { "Content-Type": "application/json" },
                // Corrected body: Wrap messages in an object and add language
                body: JSON.stringify({
                    messages: messages, // <-- Send the array under the 'messages' key
                    language: currentLang // <-- Send the language under the 'language' key
                })
            });

            if (!res.ok) {
                let errorMessage = `PDF generation failed with status: ${res.status}`;
                try {
                    // Try to parse error details if available (FastAPI sends JSON for 422)
                    const errorData = await res.json();
                    if (errorData.detail) { // FastAPI 422 errors often use 'detail'
                        errorMessage = `PDF generation failed: ${JSON.stringify(errorData.detail)}`;
                    } else if (errorData.error) { // Custom error format
                        errorMessage = errorData.error;
                    }
                } catch (e) { /* ignore JSON parse errors */ }
                throw new Error(errorMessage);
            }

            const contentType = res.headers.get('content-type');
            if (!contentType || !contentType.includes('application/pdf')) {
                // If response is OK but not PDF, try to read it as text/JSON for more info
                let responseText = await res.text();
                try {
                    const responseJson = JSON.parse(responseText);
                    if (responseJson.error) responseText = responseJson.error;
                } catch (e) { /* ignore parse error */ }
                throw new Error(`Server did not return a valid PDF file. Response: ${responseText}`);
            }


            const blob = await res.blob();
            const url = window.URL.createObjectURL(blob);
            const a = document.createElement("a");
            a.href = url;
            a.download = "PlantAI_Report.pdf";
            a.click();
            window.URL.revokeObjectURL(url);

            setMessages(prev => [...prev,
            { from: "bot", text: t.pdfDownloaded }
            ]);
        } catch (err) {
            console.error(err);
            setMessages(prev => [...prev,
            { from: "bot", text: t.pdfFailed(err) }
            ]);
        } finally {
            setIsGeneratingPDF(false);
        }
    };

    // For handling new image upload after a diagnosis
    const handleRestart = () => {
        setChatEnabled(false);
        setDiagnosisContext("");
        setMessages([
            { from: "bot", text: t.initialMessage } // Use translated initial message
        ]);
    };

    // Custom markdown components (remain style-related, no translation needed here)
    const MarkdownComponents = {
        h1: (props: any) => <h1 className="text-2xl font-bold my-4" {...props} />,
        h2: (props: any) => <h2 className="text-xl font-bold my-3" {...props} />,
        h3: (props: any) => <h3 className="text-lg font-bold my-2" {...props} />,
        ul: (props: any) => <ul className="list-disc ml-6 my-2" {...props} />,
        ol: (props: any) => <ol className="list-decimal ml-6 my-2" {...props} />,
        code: (props: any) => {
            const { children, className } = props;
            return className ? (
                <pre className="bg-gray-800 text-white p-2 rounded my-2 overflow-x-auto">
                    <code className={className}>{children}</code>
                </pre>
            ) : (
                <code className="bg-gray-200 px-1 rounded">{children}</code>
            );
        },
        blockquote: (props: any) => <blockquote className="border-l-4 border-gray-300 pl-4 italic my-2" {...props} />,
        a: (props: any) => <a className="text-blue-500 hover:underline" {...props} />,
        p: (props: any) => <p className="my-2" {...props} />,
    };


    return (
        <div className="w-[400px] h-screen text-gray-900 bg-white flex flex-col">
            <div className="p-4 text-lg font-semibold border-b flex justify-between items-center bg-green-700 text-white">
                <span>ЁЯМ┐ PlantAI Assistant</span>
                {/* Language Selector */}
                {/* Place this higher up if you want language selection always visible */}
                {/* Or keep it here, but maybe adjust flex layout */}
                <div className="flex items-center gap-2">
                    {chatEnabled && (
                        <Button onClick={handleRestart} variant="outline" size="sm" className="text-xs bg-white text-green-700 hover:bg-gray-100 h-8"> {/* Added h-8 for better alignment */}
                            {t.newDiagnosisButton}
                        </Button>
                    )}
                    <Select onValueChange={handleLanguageChange} value={currentLang}>
                        <SelectTrigger className="w-[140px] text-sm bg-white text-green-700 border-green-700 hover:bg-gray-100 h-8"> {/* Added h-8 */}
                            <SelectValue placeholder={t.selectLanguage} />
                        </SelectTrigger>
                        <SelectContent>
                            {Object.keys(languageOptions).map((langKey) => (
                                <SelectItem key={langKey} value={langKey}>
                                    {languageOptions[langKey as keyof typeof languageOptions]}
                                </SelectItem>
                            ))}
                        </SelectContent>
                    </Select>
                </div>
            </div>

            <ScrollArea ref={scrollAreaRef} className="flex-1 p-2 space-y-2 overflow-hidden">
                {messages.map((msg, i) => (
                    <div
                        key={i}
                        className={`p-3 m-2 rounded-xl max-w-[90%] ${msg.from === "bot"
                            ? "bg-gray-100 text-left ml-0 mr-auto"
                            : "bg-green-100 text-black text-left ml-auto mr-0"
                            }`}>
                        {msg.loading ? (
                            <div className="flex items-center gap-2">
                                <Loader2 className="h-4 w-4 animate-spin" />
                                <span>{t.thinking}</span>
                            </div>
                        ) : msg.from === "bot" ? (
                            <ReactMarkdown
                                components={MarkdownComponents}
                                remarkPlugins={[remarkGfm]}
                                rehypePlugins={[rehypeRaw, rehypeSanitize]}
                            >
                                {msg.text}
                            </ReactMarkdown>
                        ) : (
                            <div className="whitespace-pre-wrap">{msg.text}</div>
                        )}
                    </div>
                ))}
            </ScrollArea>

            {/* Generate Report button after diagnosis */}
            {chatEnabled && (
                <div className="p-2 border-t flex justify-center">
                    <Button
                        onClick={handleDownloadPdf}
                        disabled={isGeneratingPDF || isStreaming}
                        className="bg-green-700 hover:bg-green-800 w-full" // Make button full width
                    >
                        {isGeneratingPDF ? (
                            <>
                                <Loader2 className="h-4 w-4 mr-2 animate-spin" /> {t.generatingReport}
                            </>
                        ) : (
                            <>
                                <Download className="h-4 w-4 mr-2" /> {t.generateReportButton}
                            </>
                        )}
                    </Button>
                </div>
            )}

            {/* Image upload or chat input */}
            {!chatEnabled ? (
                <div className="p-4 border-t border-gray-300">
                    <div className="flex flex-col gap-2">
                        <div className="flex flex-row p-4 space-x-2">
                            <Button
                                onClick={() => fileInputRef.current?.click()}
                                disabled={isUploading}
                                className="bg-green-700 hover:bg-green-800 w-full" // Make button full width
                            >
                                {isUploading ? (
                                    <>
                                        <Loader2 className="h-4 w-4 mr-2 animate-spin" /> {t.uploadingButton}
                                    </>
                                ) : (
                                    <>
                                        <Upload className="h-4 w-4 mr-2" /> {t.uploadButton}
                                    </>
                                )}
                            </Button>
                            <Button>
                                <Mic/>
                            </Button>
                       </div>
                        <Input
                            ref={fileInputRef}
                            type="file"
                            accept="image/*"
                            onChange={handleImageUpload}
                            className="hidden"
                            disabled={isUploading}
                        />
                        <p className="text-xs text-gray-500 text-center">
                            {t.uploadHint}
                        </p>
                    </div>
                </div>
            ) : (
                <form
                    onSubmit={handleSend}
                    className="p-4 border-t border-gray-300 flex gap-2"
                >
                    <Input
                        value={input}
                        onChange={e => setInput(e.target.value)}
                        className="flex-1 bg-white text-gray-900"
                        placeholder={t.inputPlaceholder}
                        disabled={isStreaming}
                    />
                    <Button
                        type="submit"
                        disabled={isStreaming || !input.trim()}
                        className="bg-green-700 hover:bg-green-800"
                    >
                        {isStreaming ? <Loader2 className="h-4 w-4 animate-spin" /> : "Send"}
                    </Button>
                </form>
            )}
        </div>
    );
};

export default SideChatBot;